'''
- генератори
-  lambda-фукції
- області видимості
- декоратори
'''

# def powers(n:int) -> list:
#     for i in range(1, n + 1):
#         return i ** 2
#
# print(powers(10))

def powers(n: int):
    for i in range(1, n + 1):
        yield i ** 2
'''
Функції-генератори в Python — це функції, які використовують ключове слово yield для створення ітератора, що генерує значення "на льоту" під час виконання. Вони корисні для обробки великих послідовностей даних, оскільки не зберігають усі значення в пам'яті одночасно, а генерують їх по одному при запиті, що економить пам'ять. 
Ключові характеристики
Використання yield: Наявність хоча б одного оператора yield перетворює звичайну функцію на функцію-генератор. 
Повернення ітератора: При виклику функція-генератор не виконує код одразу, а повертає об'єкт-генератор (ітератор), який можна перебирати. 
Призупинення виконання: yield призупиняє виконання функції, зберігає її стан, а потім віддає значення. При наступному запиті виконання відновлюється з того місця, де було зупинено. 
«Ліниві» обчислення: Генератори працюють за принципом лінивої ітерації (lazy evaluation), тобто генерують значення лише тоді, коли вони потрібні, а не одразу всі. 
Одноразове використання: Після того, як усі значення згенеровано, генератор вичерпується і більше не може бути використаний. При спробі отримати наступний елемент виникає виняток StopIteration. 

def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Створення генератора
fib_gen = fibonacci_generator(5)

# Ітерація по генератору
for number in fib_gen:
    print(number)
# Вивід:
# 0
# 1
# 1
# 2
# 3
'''
    # for el in powers(10):
    #     print(el)

print(*powers(10))
print(sum(powers(10)))
generator_result = list(powers(10))
print(generator_result)

result = powers(10)
print(next(result))

'''
Lambda 

лямбда-функція (або “анонімна функція”) — це спеціальний тип функції без імені. 
lambda аргумент(и) : вираз 
Тут:

   аргумент(и) — будь-яке значення, яке передається лямбда-функції;

   вираз — цей стейтмент виконується та повертається.
   
   
'''

# Лямбда-функція, яка приймає 1 аргумент
greet_user = lambda name: print('Hey there,', name)

# Виклик лямбда-функції
greet_user('Delilah')

'''
Функція filter() в Python приймає функцію та ітерований об’єкт (списки, кортежі та рядки) як аргументи. 
Функція викликається зі всіма елементами в списку, і повертається новий список, що містить елементи, для яких функція визначила значення True.
# Програма фільтрації лише парних елементів зі списку
my_list = [1, 5, 4, 6, 8, 11, 3, 12]
 
new_list = list(filter(lambda x: (x%2 == 0) , my_list))
 
print(new_list)
'''

print(*map(lambda char: f'!{char.upper()}!', 'qwerty'))


'''
Функція map() в Python приймає функцію та об’єкт, що ітерується (списки, кортежі та рядки) як аргументи. 
Функція викликається зі всіма елементами у списку і повертається новий список, який містить елементи, що повертаються цією функцією для кожного елемента.
'''

# Програма подвоєння значень кожного елемента списку за допомогою функції map()

my_list = [1, 5, 4, 6, 8, 11, 3, 12]

new_list = list(map(lambda x: x * 2, my_list))

print(new_list)

'''
Коли ми оголошуємо змінні всередині функції, ці змінні матимуть локальну область видимості. 
Ми не можемо отримати доступ до них поза межами функції. Ці типи змінних називаються локальними змінними. 
def greet():
 
    # Локальна змінна
    message = 'Hello'
    
    print('Local', message)
 
greet()
 
# Намагаємося отримати доступ до змінної message поза функцією greet()
print(message)

Результат:

Local Hello
NameError: name 'message' is not defined


В Python змінна, оголошена поза функцією або у глобальній області видимості, називається глобальною змінною. 
Це означає, що глобальна змінна може бути доступна як всередині, так і зовні функції.

# Оголошуємо глобальну змінну
message = 'Hello'


def greet():
    # Оголошуємо локальну змінну
    print('Local', message)


greet()
print('Global', message)

'''
# var = 1
#
# def funk():
#     print(var)
#
# funk()
# var =1
#
# def funk2():
#    global var
#    var += 1
#
#
# funk2()
#
# print(var)


# Декоратори
'''
Декоратор — це функція, яка приймає іншу функцію та повертає її модифіковану версію.



'''
import time

def time_decorator(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f'Час виконання функції "{func.__name__}": {end - start} сек')
        return result

    return wrapper


@time_decorator
def timer(secs: int):
    while secs > 0:
        print(f'{secs} seconds')
        secs -= 1
        time.sleep(1)

timer(10)